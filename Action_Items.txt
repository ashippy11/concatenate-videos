### Known Issues (In Priority Order)

- Local development requires installing a disruptive dependency (ffmpeg) to one’s own machine which can lead to parity mismatch with dependency installed on the production instance.

To address this I will be Docker-izing the application. This way what devs run locally and what runs in production will have no dependency mismatch issues.
- Deployment Frequency is low bc deploying is archaic and requires manually building, ssh’ing into an EC2 instance, and starting the service. There are known hesitations from engineers because they are used to more modern continuous deployment solutions.
- Whenever the EC2 instance is restarted all jobs are lost
- Knowledge around infrastructure configured for the services is not known or readily available (assume clean slate is required). Developers expect all services and supporting infra can be run locally.
- When the job processor crashes it causes the api to go down with it

This was a frusterating bug I noticed during testing. Often time a Downlaod would not complete witht teh following error:

mov,mp4,m4a,3gp,3g2,mj2 @ 0xaaaaf96472f0] moov atom not found
/tmp/test2/5b42ac84-7215-4e61-9533-5f26904e8ce5/0.mp4: Invalid data found when processing input


/app/node_modules/fluent-ffmpeg/lib/ffprobe.js:233
          handleExit(new Error('ffprobe exited with code ' + code));

It would happen intermittenly with the same files.

In order to fix this the job processor needs to be isolated from the main application. One option woudld be to run these
two proceses as different microservices completely. With the API running in its own infra....
- Mean Time To Resolve (MTTR) is on the order of a day. There is no observability or monitoring in place and the sparse logs that are present are difficult to track down. The team is in a reactive position, they need to be in an offensive position with the services